#pragma config(Hubs,  S1, HTMotor,  HTServo,  none,     none)
#pragma config(Sensor, S3,     msensor,        sensorI2CCustom)
#pragma config(Sensor, S4,     IR_Sensor,      sensorI2CCustomFast)
#pragma config(Motor,  mtr_S1_C1_1,     leftMotor,     tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     rightMotor,    tmotorTetrix, openLoop, encoder)
#pragma config(Servo,  srvo_S1_C2_1,    gripperElbow,         tServoStandard)
#pragma config(Servo,  srvo_S1_C2_2,    gripperWrist,         tServoStandard)
#pragma config(Servo,  srvo_S1_C2_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int dir;
int irStrength1, irStrength2, irStrength3, irStrength4, irStrength5;
int position;
int compassOffset;
int direction;
int counter = 0;
int delta;
float gain=1;

#include "hitechnic-irseeker-v2.h"
#include "JoystickDriver.c";
#include "hitechnic-sensormux.h";
#include "hitechnic-compass.h";
#include "lego-touch.h";
#include "lego-ultrasound.h";

void executeGeneral();
int getMax();
int getAngle(int direction);
int getAngleCounterClockwise(int direction);
int rightMulti = 1.5;

void goStrait(float dist);
void goStraitBack(float dist);
void turnClockwise(int angle);
void turnCounterClockwise(int angle);
int getAngleDif(int angle);

task main()
{


/*while(true){
getMax();	
}*/
  goStrait(2);
  //
  turnCounterClockwise(70);
  //
  
  
	if(getMax()>50){
		turnClockwise(70);
    goStrait(1);

	  executeGeneral();
  }
else{
	counter=0;

  	 compassOffset=HTMCreadHeading(msensor_S3_3);
     while(counter <3){
  	  motor[leftMotor]=10;
			motor[rightMotor]=30;
		if(HTMCreadHeading(msensor_S3_3)-compassOffset>=45){
		counter++;
		}
		else{
			counter=0;
		}
  }

	if(getMax()>50){
		turnClockwise(70);
    goStrait(0.5);
 
	  executeGeneral();
  }
  else{
  	counter=0;

  	 compassOffset=HTMCreadHeading(msensor_S3_3);
     while(counter<3){
  	  motor[leftMotor]=15;
			motor[rightMotor]=30;
					if(HTMCreadHeading(msensor_S3_3)-compassOffset>=28){
		counter++;
		}
		else{
			counter=0;
		}
  }
    	  motor[leftMotor]=0;
			motor[rightMotor]=0;
	turnClockwise(97);
    goStrait(0.5);

  	  executeGeneral();
  }
 }




}

void executeGeneral(){
	wait1Msec(1000);
     goStraitBack(0.5);
     turnClockwise(80);
     goStrait(1);
     turnCounterClockwise(70);
     motor[leftMotor]=100;
     motor[rightMotor]=100;
     wait1Msec(2000);

}
int getMax(){
		HTIRS2readAllACStrength(IR_sensor,irStrength1,irStrength2,irStrength3,irStrength4,irStrength5);
int currentMax=0;
if(irStrength1>currentMax){
   currentMax=irStrength1;
}
if(irStrength2>currentMax){
   currentMax=irStrength2;
}
if(irStrength3>currentMax){
   currentMax=irStrength3;
}
if(irStrength4>currentMax){
   currentMax=irStrength4;
}
if(irStrength5>currentMax){
   currentMax=irStrength5;
}
return currentMax;

}

int getAngle(int direction){
	int toReturn=0;
  if(direction<-5){
  	return direction+360;
  }
  else if(direction<0){
  	return 0;
  }
  else{
  return direction;
}
}
int getAngleCounterClockwise(int direction){
	int toReturn=0;
  if(direction>5){
  	return direction-360;
  }
  else if(direction>0){
  	return 0;
  }
  else{
  return direction;
}
}

void goStrait(float dist){
			    nMotorEncoder[leftMotor]=0;
    nMotorEncoder[rightMotor]=0;
    compassOffset=HTMCreadHeading(msensor_S3_3);
    

    while(nMotorEncoder[rightMotor]<dist*1120){

    	delta = getAngleDif(HTMCreadHeading(msensor_S3_3) - compassOffset);

     	motor[leftMotor] = 50+delta*gain;
			motor[rightMotor]= 50-delta*gain;
  }
  motor[leftMotor]=0;
  motor[rightMotor]=0;

}
void goStraitBack(float dist){
			    nMotorEncoder[leftMotor]=0;
    nMotorEncoder[rightMotor]=0;
    compassOffset=HTMCreadHeading(msensor_S3_3);
    

    while(nMotorEncoder[rightMotor]>-dist*1120){

    	delta = getAngleDif(HTMCreadHeading(msensor_S3_3) - compassOffset);

     	motor[leftMotor] = -50-delta*gain;
			motor[rightMotor]= -50+delta*gain;
  }
  motor[leftMotor]=0;
  motor[rightMotor]=0;

}
void turnClockwise(int angle){

    	 compassOffset=HTMCreadHeading(msensor_S3_3);
    	 counter=0;
     while(counter<3){
       direction=getAngle(HTMCreadHeading(msensor_S3_3)-compassOffset);
  	  motor[leftMotor]=-20;
			motor[rightMotor]=20*rightMulti;
			if(getAngle(HTMCreadHeading(msensor_S3_3)-compassOffset)>=angle){
		counter++;
		}
		else{
			counter=0;
		}
  }
 
    motor[leftMotor]=0;
    motor[rightMotor]=0;
     wait1Msec(1000);
}
void turnCounterClockwise(int angle){
	 counter=0;
  compassOffset=HTMCreadHeading(msensor_S3_3);
  while(counter <3 ){
  	  motor[leftMotor]=20;
			motor[rightMotor]=-20*rightMulti;
       direction=getAngleCounterClockwise(HTMCreadHeading(msensor_S3_3)-compassOffset);
			if(getAngleCounterClockwise(HTMCreadHeading(msensor_S3_3)-compassOffset)<=-angle){
		counter++;
		}
		else{
			counter=0;
		}
  }
  motor[leftMotor]=0;
  motor[rightMotor]=0;
   wait1Msec(1000);
}
int getAngleDif(int angle){
	if(angle>180){
	   return 360-angle;	
  }
  else if(angle<-180){
     return -360-angle;	
  }
  else{
     return angle;	
  }
}
