#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     msensor,        sensorI2CCustom)
#pragma config(Sensor, S3,     IR_sensor,      sensorI2CCustomFastSkipStates)
#pragma config(Motor,  mtr_S1_C1_1,     rightMotor,    tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     leftMotor,     tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     motorF,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     motorG,        tmotorTetrix, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int dir;
int irStrength1, irStrength2, irStrength3, irStrength4, irStrength5;
int position;
int compassOffset;
int direction;
int counter = 0;


#include "hitechnic-irseeker-v2.h"
#include "JoystickDriver.c";
#include "hitechnic-sensormux.h";
#include "hitechnic-compass.h";
#include "lego-touch.h";
#include "lego-ultrasound.h";

void executeGeneral();
int getMax();
int getAngle(int direction);
int getAngleCounterClockwise(int direction);


task main()
{


HTIRS2setDSPMode(IR_sensor,DSP_1200);
	    nMotorEncoder[leftMotor]=0;
    nMotorEncoder[rightMotor]=0;
    while(nMotorEncoder[rightMotor]<3.4*1120){
    	motor[leftMotor]=25;
			motor[rightMotor]=20;
  }
  counter=0;
  compassOffset=HTMCreadHeading(msensor_S2_3);
  while(HTMCreadHeading(msensor_S2_3)-compassOffset>-90 || counter <3 ){
  	  motor[leftMotor]=-10;
			motor[rightMotor]=10;
			if(HTMCreadHeading(msensor_S2_3)-compassOffset<=-90){
		counter++;		
		}
		else{
			counter=0;
		}
  }
	if(getMax()>20){
	  executeGeneral(); 	
  }
else{
	counter=0;
  	 compassOffset=HTMCreadHeading(msensor_S2_3);
     while(HTMCreadHeading(msensor_S2_3)-compassOffset<30 || counter <3){
  	  motor[leftMotor]=40;
			motor[rightMotor]=10;
		if(HTMCreadHeading(msensor_S2_3)-compassOffset>=30){
		counter++;		
		}
		else{
			counter=0;
		}
  }  

	if(getMax()>20){
	  executeGeneral(); 	
  }
  else{
  	counter=0;
  	 compassOffset=HTMCreadHeading(msensor_S2_3);
     while(HTMCreadHeading(msensor_S2_3)-compassOffset<45 || counter<3){
  	  motor[leftMotor]=30;
			motor[rightMotor]=10;
					if(HTMCreadHeading(msensor_S2_3)-compassOffset>=45){
		counter++;		
		}
		else{
			counter=0;
		}
  }
  	  executeGeneral(); 
  }
 }




}

void executeGeneral(){
	//turn back to forward
  	  motor[leftMotor]=0;
			motor[rightMotor]=0;
    	 compassOffset=HTMCreadHeading(msensor_S2_3);
    	 counter=0;
     while(counter<3){
       direction=getAngle(HTMCreadHeading(msensor_S2_3)-compassOffset);
  	  motor[leftMotor]=10;
			motor[rightMotor]=-10;
			if(getAngle(HTMCreadHeading(msensor_S2_3)-compassOffset)>=90){
		counter++;
		}
		else{
			counter=0;
		}
  }
  
  //go until button press
    	  motor[leftMotor]=0;
			motor[rightMotor]=0;
				while(TSreadState(msensor_S2_2)==0)
	{
	  motor[leftMotor]=20;
		motor[rightMotor]=20;	
		
  }
  
  //backup
  	  nMotorEncoder[leftMotor]=0;
      nMotorEncoder[rightMotor]=0;
      while(nMotorEncoder[rightMotor]>-2*1120){
    	motor[leftMotor]=-10;
			motor[rightMotor]=-10;
  }
  //turn 180
    counter=0;
      	 compassOffset=HTMCreadHeading(msensor_S2_3);
     while(counter<3){
  	  motor[leftMotor]=10;
			motor[rightMotor]=-10;
						if(getAngle(HTMCreadHeading(msensor_S2_3)-compassOffset)>=180){
		counter++;		
		}
		else{
			counter=0;
		}
  }
    motor[leftMotor]=0;
			motor[rightMotor]=0;
  wait1msec(2000);
  //turn to kickstand
  counter=0;
      	 compassOffset=HTMCreadHeading(msensor_S2_3);
     while(counter<3){
  	  motor[leftMotor]=-10;
			motor[rightMotor]=10;
						if(getAngleCounterClockwise(HTMCreadHeading(msensor_S2_3)-compassOffset)<=-120){
		counter++;		
		}
		else{
			counter=0;
		}
  }
  //drive to kickstand
   nMotorEncoder[leftMotor]=0;
      nMotorEncoder[rightMotor]=0;
      while(nMotorEncoder[rightMotor]<5*1120){
    	motor[leftMotor]=13;
			motor[rightMotor]=30;
  }
			

}
int getMax(){
		HTIRS2readAllACStrength(IR_sensor,irStrength1,irStrength2,irStrength3,irStrength4,irStrength5);
int currentMax=0;	
if(irStrength1>currentMax){
   currentMax=irStrength1;	
}
if(irStrength2>currentMax){
   currentMax=irStrength2;	
}
if(irStrength3>currentMax){
   currentMax=irStrength3;	
}
if(irStrength4>currentMax){
   currentMax=irStrength4;	
}
if(irStrength5>currentMax){
   currentMax=irStrength5;	
}
return currentMax;

}

int getAngle(int direction){
	int toReturn=0;
  if(direction<-5){
  	return direction+360;
  }
  else if(direction<0){
  	return 0;
  }
  else{
  return direction; 	
}
}
int getAngleCounterClockwise(int direction){
	int toReturn=0;
  if(direction>5){
  	return direction-360;
  }
  else if(direction>0){
  	return 0;
  }
  else{
  return direction;
}
}
