#pragma config(Hubs,  S1, HTMotor,  HTServo,  none,     none)
#pragma config(Sensor, S2,     msensor,        sensorI2CCustom)
#pragma config(Sensor, S3,     IR_sensor,      sensorI2CCustom)
#pragma config(Motor,  mtr_S1_C1_1,     rightMotor,    tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     leftMotor,     tmotorTetrix, openLoop, encoder)
#pragma config(Servo,  srvo_S1_C2_1,    servo1,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int dir;
int irStrength1, irStrength2, irStrength3, irStrength4, irStrength5;
int strength;
int position;
int compassOffset;



#include "hitechnic-irseeker-v2.h"
#include "JoystickDriver.c";
#include "hitechnic-sensormux.h";
#include "hitechnic-compass.h";
#include "lego-touch.h";
#include "lego-ultrasound.h";
task main()
{
	HTIRS2setDSPMode(IR_sensor,DSP_1200);
	dir = HTIRS2readACDir(IR_sensor);
	HTIRS2readAllACStrength(IR_sensor,irStrength1,irStrength2,irStrength3,irStrength4,irStrength5);
	if(irStrength3>50){
			position=1;	
  }
  else if(irStrength3>9){
     position=2; 	
}
else{
     position=3;	
}
  nxtDisplayTextLine(0,"position: %d",position);
 	
  if(position==position){
  	//to center
    while(TSreadState(msensor_S2_2)==0){
    			motor[leftMotor]=-35;
			motor[rightMotor]=-50;	
   }
   //back
  	nMotorEncoder[leftMotor]=0;
    nMotorEncoder[rightMotor]=0;
		while(nMotorEncoder[rightMotor]>2*-1120){    
		motor[leftMotor]=15;
		motor[rightMotor]=20;
		}
		//turn right
    nMotorEncoder[leftMotor]=0;
    nMotorEncoder[rightMotor]=0;
    while(nMotorEncoder[leftMotor]<1120){
    	motor[leftMotor]=0;
			motor[rightMotor]=-20;
  }
  //forward
  	nMotorEncoder[leftMotor]=0;
    nMotorEncoder[rightMotor]=0;
		while(nMotorEncoder[rightMotor]<1.2*1120){
     motor[leftMotor]=-15;
		motor[rightMotor]=-20;
		}
		//turn left
		 nMotorEncoder[leftMotor]=0;
    nMotorEncoder[rightMotor]=0;
    while(nMotorEncoder[rightMotor]<1*1120){
    	motor[leftMotor]=-20;
			motor[rightMotor]=0;
  }
  //forward
  		  nMotorEncoder[leftMotor]=0;
      nMotorEncoder[rightMotor]=0;
		  while(nMotorEncoder[leftMotor]<2.5*1120){
     motor[leftMotor]=-22;
		motor[rightMotor]=-20;
	}
		//hook
	while(true){
		  nMotorEncoder[leftMotor]=0;
      nMotorEncoder[rightMotor]=0;
		  while(nMotorEncoder[leftMotor]<1*1120){
    	motor[leftMotor]=90;
			motor[rightMotor]=-100;
		}
			nMotorEncoder[leftMotor]=0;
      nMotorEncoder[rightMotor]=0;
		  while(nMotorEncoder[leftMotor]>-1*1120){
    	motor[leftMotor]=-100;
			motor[rightMotor]=90;

	}
  }
  
  }
}
