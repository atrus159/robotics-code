#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Hubs,  S2, HTMotor,  HTServo,  none,     none)
#pragma config(Sensor, S3,     compass,        sensorI2CCustom)
#pragma config(Sensor, S4,     ,               sensorI2CCustom)
#pragma config(Motor,  mtr_S1_C1_1,     flyWheel,      tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     intake,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     leftMotor,     tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     lift,          tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S2_C1_1,     rightMotor,    tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S2_C1_2,     motorI,        tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S2_C2_1,    gripper,              tServoStandard)
#pragma config(Servo,  srvo_S2_C2_2,    patriot,              tServoStandard)
#pragma config(Servo,  srvo_S2_C2_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S2_C2_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S2_C2_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S2_C2_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c";
// #include "hitechnic-sensormux.h";
#include "hitechnic-compass.h";
// #include "lego-touch.h";
// #include "lego-ultrasound.h";

int getAngleClockwise(int direction);
int getAngleCounterClockwise(int direction);

void goStrait(float dist, float speed, float compOff);
void goStraitBack(float dist, float speed, float compOff);
void turnClockwise(int angle, float compOff);
void turnCounterClockwise(int angle, float compOff);

void lowerGripper();
void raiseGripper();
int getAngleDif(int angle);
void goTo(int stage);
int direction;
int counter;
int compassOffset;
int rightMulti = 1;
int delta;
float gain=1;


task main()
{
nMotorPIDSpeedCtrl[leftMotor]=mtrSpeedReg;
nMotorPIDSpeedCtrl[rightMotor]=mtrSpeedReg;
int delta;
float gain = 1;
		nMotorEncoder[leftMotor]=0;
    nMotorEncoder[rightMotor]=0;
waitForStart();

/*while(true){
compassOffset=HTMCreadHeading(compass);
}*/
float initial = HTMCreadHeading(compass);
   raiseGripper();
     wait1Msec(2000);
     //
		    nMotorEncoder[leftMotor]=0;
    nMotorEncoder[rightMotor]=0;
      while((nMotorEncoder[rightMotor]+nMotorEncoder[leftMotor])/2>-2*1120){
      motor[leftMotor]=-50;
      motor[rightMotor]=-50;
      }
      motor[leftMotor]=0;
      motor[rightMotor]=0;
	//

	goStraitBack(0.7,10,initial);
  lowerGripper();
  wait1Msec(2000);
return;
 ///////////////////////////////////////
    	 compassOffset=initial;
    	 counter=0;
     while(counter<3){
       direction=getAngleClockwise(HTMCreadHeading(compass)-compassOffset);
  	  motor[leftMotor]=60;
			motor[rightMotor]=-1*rightMulti;
			if(getAngleClockwise(HTMCreadHeading(compass)-compassOffset)>=60){
		counter++;
		}
		else{
			counter=0;
		}
  }
       motor[leftMotor]=0;
			motor[rightMotor]=0;
		///////////////////////////////////////////////////////
  	goStrait(3.5,20,initial);
/////////////////////////////////////////////////////
      turnCounterClockwise(60,initial);
      ////////////////////////////////////
		goStrait(4,20,initial);
		///////////////////
      turnCounterClockwise(110,initial);
}

int getAngleClockwise(int direction){

  if(direction<-10){
  	return direction+360;
  }
  else if(direction<0){
  	return 0;
  }
  else{
  return direction;
}
}
int getAngleCounterClockwise(int direction){

  if(direction>10){
  	return direction-360;
  }
  else if(direction>0){
  	return 0;
  }
  else{
  return direction;
}
}
void lowerGripper(){
servo[gripper] = 130;
}

void raiseGripper(){
servo[gripper] = 110;
}
void turnClockwise(int angle, float compOff){

    	 compassOffset=compOff;
    	 counter=0;
     while(counter<3){
       direction=getAngleClockwise(HTMCreadHeading(compass)-compassOffset);
  	  motor[leftMotor]=-20;
			motor[rightMotor]=20*rightMulti;
			if(getAngleClockwise(HTMCreadHeading(compass)-compassOffset)>=angle){
		counter++;
		}
		else{
			counter=0;
		}
  }

    motor[leftMotor]=0;
    motor[rightMotor]=0;
     wait1Msec(1000);
}



void turnCounterClockwise(int angle, float compOff){
	 counter=0;
  compassOffset=compOff;
  while(counter <3 ){
  	  motor[leftMotor]=20;
			motor[rightMotor]=-20*rightMulti;
       direction=getAngleCounterClockwise(HTMCreadHeading(compass)-compassOffset);
			if(getAngleCounterClockwise(HTMCreadHeading(compass)-compassOffset)<=-angle){
		counter++;
		}
		else{
			counter=0;
		}
  }
  motor[leftMotor]=0;
  motor[rightMotor]=0;
   wait1Msec(1000);
}
void goStrait(float dist, float speed, float compOff){
			    nMotorEncoder[leftMotor]=0;
    nMotorEncoder[rightMotor]=0;
    compassOffset=compOff;


    while((nMotorEncoder[rightMotor]+nMotorEncoder[leftMotor])/2<dist*1120){

    	delta = getAngleDif(HTMCreadHeading(compass) - compassOffset);

     	motor[leftMotor] = speed+delta*gain;
			motor[rightMotor]= speed-delta*gain;
  }
  motor[leftMotor]=0;
  motor[rightMotor]=0;

}
void goStraitBack(float dist, float speed, float compOff){
			    nMotorEncoder[leftMotor]=0;
    nMotorEncoder[rightMotor]=0;
    compassOffset=compOff;


    while((nMotorEncoder[rightMotor]+nMotorEncoder[leftMotor])/2>-dist*1120){

    	delta = getAngleDif(HTMCreadHeading(compass) - compassOffset);

     	motor[leftMotor] = -speed-delta*gain;
			motor[rightMotor]= -speed+delta*gain;
  }
  motor[leftMotor]=0;
  motor[rightMotor]=0;

}
int getAngleDif(int angle){
	if(angle>180){
	   return 360-angle;
  }
  else if(angle<-180){
     return -360-angle;
  }
  else{
     return angle;
  }
}

void goTo(int stage){
	int heights[] = {0,3,7,13};
	motor[lift]=0;

	if(nMotorEncoder[lift]< heights[stage]){
		while (nMotorEncoder[lift] < 1120*heights[stage] ) {
				motor[lift] =50;

			}
			motor[lift]=0;
					return;
	}
	else{
				while (nMotorEncoder[lift] > -1120*heights[stage] ) {
				motor[lift] = -10;

			}
			motor[lift]=0;
					return;
	motor[lift]=0;
		return;
}

}
